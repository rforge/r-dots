#########################################################################/**
# @RdocDefault loadCache
#
# @title "Loads data from file cache"
#
# \description{
#  @get "title", which is unique for an optional key object.
# }
#
# @synopsis
#
# \arguments{
#   \item{key}{An optional object from which a hexadecimal hash
#     code will be generated and appended to the filename.}
#   \item{sources}{Optional source objects.  If the cache object has a 
#     timestamp older than one of the source objects, it will be ignored 
#     and removed.}
#   \item{suffix}{A @character string to be appended to the end of the
#     filename.}
#   \item{removeOldCache}{If @TRUE and the cache is older than the
#     \code{sources}, the cache file is removed, otherwise not.}
#   \item{pathname}{The pathname to the cache file.  If specified,
#     arguments \code{key} and \code{suffix} are ignored.  Note that
#     this is only needed in order to read a cache file for which
#     the key is unknown, for instance, in order to investigate
#     an unknown cache file.}
#   \item{dirs}{A @character @vector constituting the path to the
#      cache subdirectory to be used. If @NULL, the root path is used.}
#   \item{...}{Additional argument passed to @see "base::load".}
# }
#
# \value{
#   Returns an \R object or @NULL, if cache does not exist.
# }
#
# \details{
#   The hash code calculated from the \code{key} object is a 
#   32 characters long hexadecimal MD5 hash code.  For more details,
#   see the \emph{digest} package.
# }
#
# \section{Requirements}{
#  To make use of the \code{key} argument, the \emph{digest} package 
#  (available on CRAN) must be installed, otherwise an error is generated.
#  That package is not required when \code{key==NULL}.
# }
#
# @author
#
# @examples "../incl/loadCache.Rex"
#
# \seealso{
#  @see "saveCache".
#  The @see "Biobase::cache" method in Bioconductor.
# }
#
# @keyword "programming"
# @keyword "IO"
#*/#########################################################################
setMethodS3("loadCache", "default", function(key=NULL, sources=NULL, suffix=".Rcache", removeOldCache=TRUE, pathname=NULL, dirs=NULL, ...) {
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Load functions
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Same a base::load(), but it does not open a gzcon() connection, which
  # cause problem because that reset file connections to position zero.
  baseLoad <- function(con, envir=parent.frame()) {
    magic <- readChar(con, 5);
    if (regexpr("RD[AX]2\n", magic) == -1) {
      if (regexpr("RD[ABX][12]\r", magic) == 1) {
        stop("input has been corrupted, with LF replaced by CR");
      } else {
        stop("the input does not start with a magic number compatible with loading from a connection");
      }
    } else {
      .Internal(loadFromConn(con, envir));
    }
  }

  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Find cached file
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  if (is.null(pathname))
    pathname <- findCache(key=key, suffix=suffix, dirs=dirs);
  if (is.null(pathname))
    return(NULL);

  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Try to load cached object from file connection
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  if (!isFile(pathname))
    return(NULL);

  fh <- file(pathname, open="rb");
  on.exit({
    if (!is.null(fh))
      close(fh);
  });

  tryCatch({
    header <- readCacheHeader(fh);
    if (!is.null(sources))
      header$sources <- sources;

    attachLocally(header);
    if (!is.null(timestamp) && !is.null(sources)) {
      for (pathname in sources) {
        if (!is.character(sources)) {
          warning("No timestamp check of cache was performed. Unsupported type of cache source: ", class(sources)[1]);
          break;
        }

        if (!file.exists(pathname)) {
          warning("No timestamp check of cache was performed. Source file not found: ", pathname);
          break;
        }

        # Is source file newer than cache?
        lastModified <- file.info(pathname)$mtime;
        if (lastModified > timestamp) {
          # Remove out-of-date cache file?
          if (removeOldCache) {
            close(fh); fh <- NULL;
            file.remove(pathname);
          }
          return(NULL);
        }
      } # for (pathname in sources)
    }

    # 4. Load cached object:
    object <- NULL;  # To please 'codetools' in R v2.6.0
    vars <- baseLoad(con=fh, ...);  # 'vars' holds names of loaded objects
    if (!identical(vars, "object")) {
      throw("Rcache file format error ('", pathname, 
            "'). Expected 'object' object: ", paste(vars, collapse=", "));
    }

    # 5. Return cached object
    return(object);
  }, error = function(ex) {
     print(ex);
  })

  NULL;
})


############################################################################
# HISTORY:
# 2008-02-14
# o Now errors reports the pathname, if available.
# 2006-08-09
# o Added link to cache() in Biobase.
# 2006-05-25
# o Added argument 'pathname' to make it possible to load a cache file
#   explicitly.
# 2006-04-04
# o Added header comment for file format > v0.1.
# o Added detection of file format version.
# 2005-12-09
# o Added support for internal 'cache' and 'timestamp' objects.
# 2005-12-06
# o Created.
############################################################################
